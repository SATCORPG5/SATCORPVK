<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Parallax — Wild Depth</title>
<style>
  :root{
    --bg0:#02030a;
    --bg1:#050b18;
    --neon:#00ff9c;
    --violet:#7f5cff;
    --glow: 0 0 18px rgba(0,255,156,.35), 0 0 36px rgba(127,92,255,.18);
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:radial-gradient(1200px 800px at 50% 30%, var(--bg1), var(--bg0));overflow:hidden;color:#fff;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}
  .stage{
    position:fixed; inset:0;
    perspective: 1100px;
    transform-style: preserve-3d;
    background:
      radial-gradient(800px 500px at 20% 20%, rgba(0,255,156,.10), transparent 60%),
      radial-gradient(700px 600px at 80% 30%, rgba(127,92,255,.10), transparent 60%),
      radial-gradient(900px 700px at 50% 80%, rgba(255,255,255,.05), transparent 65%);
  }
  .scene{
    position:absolute; inset:0;
    transform-style: preserve-3d;
    will-change: transform;
  }

  /* Depth planes */
  .layer{
    position:absolute; inset:-12vh -12vw;
    transform-style: preserve-3d;
    will-change: transform;
    pointer-events:none;
  }

  /* Grid (deep) */
  .grid{
    background:
      linear-gradient(to right, rgba(0,255,156,.10) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(0,255,156,.10) 1px, transparent 1px);
    background-size: 56px 56px;
    opacity:.45;
    filter: drop-shadow(0 0 16px rgba(0,255,156,.10));
    mask-image: radial-gradient(closest-side at 50% 60%, rgba(0,0,0,1), rgba(0,0,0,0));
  }

  /* Stars */
  .stars{
    background:
      radial-gradient(1px 1px at 10% 20%, rgba(255,255,255,.8), transparent 60%),
      radial-gradient(1px 1px at 30% 70%, rgba(255,255,255,.7), transparent 60%),
      radial-gradient(1px 1px at 55% 35%, rgba(255,255,255,.75), transparent 60%),
      radial-gradient(1px 1px at 80% 60%, rgba(255,255,255,.7), transparent 60%),
      radial-gradient(1px 1px at 90% 25%, rgba(255,255,255,.8), transparent 60%),
      radial-gradient(1px 1px at 15% 85%, rgba(255,255,255,.6), transparent 60%),
      radial-gradient(1px 1px at 45% 90%, rgba(255,255,255,.6), transparent 60%);
    opacity:.55;
    filter: blur(.1px);
  }

  /* Mist */
  .mist{
    background:
      radial-gradient(700px 420px at 30% 40%, rgba(0,255,156,.14), transparent 62%),
      radial-gradient(800px 540px at 70% 55%, rgba(127,92,255,.14), transparent 62%),
      radial-gradient(900px 600px at 50% 70%, rgba(255,255,255,.06), transparent 65%);
    mix-blend-mode: screen;
    filter: blur(1px) saturate(1.1);
    opacity:.9;
  }

  /* Floating shards */
  .shard{
    position:absolute;
    width: 220px; height: 14px;
    border-radius: 999px;
    background: linear-gradient(90deg, transparent, rgba(0,255,156,.9), rgba(127,92,255,.7), transparent);
    filter: drop-shadow(0 0 18px rgba(0,255,156,.25)) drop-shadow(0 0 24px rgba(127,92,255,.18));
    opacity:.85;
  }
  .shard::after{
    content:"";
    position:absolute; inset:-14px -28px;
    background: radial-gradient(closest-side, rgba(0,255,156,.18), transparent 70%);
    opacity:.75;
  }

  /* HUD core */
  .hud{
    position:absolute; inset:0;
    display:grid; place-items:center;
    pointer-events:none;
    transform-style: preserve-3d;
  }
  .card{
    pointer-events:none;
    padding: 18px 18px 14px;
    border-radius: 18px;
    background: rgba(5,10,20,.45);
    border: 1px solid rgba(0,255,156,.18);
    box-shadow: 0 10px 30px rgba(0,0,0,.45), var(--glow);
    backdrop-filter: blur(10px);
    transform: translateZ(120px);
    width: min(720px, calc(100vw - 28px));
  }
  .topline{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; margin-bottom:10px; opacity:.95;
  }
  .badge{
    display:inline-flex; align-items:center; gap:10px;
    font-size:12px; letter-spacing:.14em; text-transform:uppercase;
    color: rgba(255,255,255,.86);
  }
  .dot{
    width:10px; height:10px; border-radius:999px;
    background: var(--neon);
    box-shadow: 0 0 16px rgba(0,255,156,.65);
  }
  .time{
    font-size:12px; letter-spacing:.12em;
    color: rgba(255,255,255,.65);
  }
  h1{
    font-size: clamp(1.6rem, 4.2vw, 3rem);
    letter-spacing:.18em;
    text-transform:uppercase;
    text-shadow: 0 0 22px rgba(0,255,156,.22), 0 0 28px rgba(127,92,255,.12);
  }
  .sub{
    margin-top:8px;
    color: rgba(255,255,255,.75);
    line-height:1.5;
    font-size: 14px;
  }
  .hint{
    margin-top:12px;
    display:flex; gap:10px; flex-wrap:wrap;
    color: rgba(255,255,255,.55);
    font-size:12px; letter-spacing:.08em;
  }
  .pill{
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.18);
  }

  /* Scanlines */
  .scanlines{
    position:fixed; inset:0; pointer-events:none; z-index:5;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,0.03),
      rgba(255,255,255,0.03) 1px,
      transparent 1px,
      transparent 3px
    );
    mix-blend-mode: overlay;
    opacity:.55;
  }

  /* Respect reduced motion */
  @media (prefers-reduced-motion: reduce){
    .scene{ transform:none !important; }
    .layer{ transform:none !important; }
  }
</style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="scene" id="scene">

      <!-- Far -->
      <div class="layer stars" data-depth="0.06"></div>

      <!-- Deep grid -->
      <div class="layer grid" data-depth="0.12" style="transform: translateZ(-240px) scale(1.2) rotateX(12deg);"></div>

      <!-- Mid mist -->
      <div class="layer mist" data-depth="0.20"></div>

      <!-- Shards -->
      <div class="layer" data-depth="0.34" id="shards"></div>

      <!-- HUD -->
      <div class="hud layer" data-depth="0.46">
        <div class="card">
          <div class="topline">
            <div class="badge"><span class="dot"></span> DEPTH PARALLAX</div>
            <div class="time" id="clock">--:--:--</div>
          </div>
          <h1>3D PARALLAX FIELD</h1>
          <div class="sub">
            Move your mouse (or tilt on mobile) — layers shift in real 3D space, with inertia + micro-jitter.
          </div>
          <div class="hint">
            <span class="pill">Inertia</span>
            <span class="pill">Perspective</span>
            <span class="pill">DeviceOrientation</span>
            <span class="pill">No libraries</span>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div class="scanlines"></div>

<script>
(() => {
  const scene = document.getElementById("scene");
  const layers = Array.from(document.querySelectorAll(".layer[data-depth]"));
  const shardsWrap = document.getElementById("shards");

  // Spawn some neon shards in 3D
  const shardCount = 14;
  for (let i = 0; i < shardCount; i++){
    const s = document.createElement("div");
    s.className = "shard";
    const x = Math.random() * 100;
    const y = Math.random() * 100;
    const rot = (Math.random() * 120) - 60;
    const z = (Math.random() * 420) - 120; // some in front, some behind
    const scale = 0.6 + Math.random() * 1.1;
    s.style.left = x + "%";
    s.style.top = y + "%";
    s.style.transform =
      `translate3d(-50%, -50%, ${z}px) rotateZ(${rot}deg) scale(${scale})`;
    s.style.opacity = 0.55 + Math.random() * 0.45;
    shardsWrap.appendChild(s);
  }

  // Target input (mouse / touch / tilt)
  const target = { x: 0, y: 0 };
  const current = { x: 0, y: 0 };

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;

  function setTargetFromPointer(px, py){
    const nx = (px / window.innerWidth) * 2 - 1;   // -1..1
    const ny = (py / window.innerHeight) * 2 - 1;  // -1..1
    target.x = clamp(nx, -1, 1);
    target.y = clamp(ny, -1, 1);
  }

  window.addEventListener("mousemove", (e) => setTargetFromPointer(e.clientX, e.clientY), { passive:true });
  window.addEventListener("touchmove", (e) => {
    if (!e.touches || !e.touches[0]) return;
    setTargetFromPointer(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive:true });

  // Device tilt support (mobile). Must be user-gesture-enabled on iOS; we try politely.
  async function enableTilt(){
    try{
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function"){
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== "granted") return;
      }
      window.addEventListener("deviceorientation", (e) => {
        // gamma: left-right (-90..90), beta: front-back (-180..180)
        const gx = (e.gamma || 0) / 30;  // scale to ~-1..1
        const gy = (e.beta  || 0) / 30;
        // Blend tilt into target (tilt feels better as subtle)
        target.x = clamp(lerp(target.x, gx, 0.15), -1, 1);
        target.y = clamp(lerp(target.y, gy, 0.15), -1, 1);
      }, { passive:true });
    }catch(_){}
  }

  // Kick tilt on first tap (best practice)
  window.addEventListener("pointerdown", enableTilt, { once:true });

  // Wild micro-jitter
  let t0 = performance.now();

  function tick(now){
    const dt = Math.min(0.033, (now - t0) / 1000);
    t0 = now;

    // inertia
    const ease = 1 - Math.pow(0.001, dt); // framerate independent
    current.x = lerp(current.x, target.x, ease * 0.12);
    current.y = lerp(current.y, target.y, ease * 0.12);

    // subtle breathing wobble
    const wobX = Math.sin(now * 0.0013) * 0.08;
    const wobY = Math.cos(now * 0.0011) * 0.08;

    // scene tilt (bigger movement)
    const rotY = (current.x + wobX) * 14;
    const rotX = -(current.y + wobY) * 10;

    // a tiny camera push/pull
    const camZ = 40 + Math.sin(now * 0.001) * 10;

    scene.style.transform = `translateZ(${camZ}px) rotateX(${rotX}deg) rotateY(${rotY}deg)`;

    // per-layer parallax (depth drives translation)
    for (const layer of layers){
      const d = parseFloat(layer.dataset.depth) || 0;
      const tx = (current.x + wobX) * 70 * d;
      const ty = (current.y + wobY) * 55 * d;

      // more depth also gets a little Z
      const tz = d * 120;

      layer.style.transform = `translate3d(${tx}px, ${ty}px, ${tz}px)`;
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Clock
  const clock = document.getElementById("clock");
  function updateClock(){
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    const ss = String(d.getSeconds()).padStart(2,"0");
    clock.textContent = `${hh}:${mm}:${ss}`;
  }
  updateClock();
  setInterval(updateClock, 1000);
})();
</script>
</body>
</html>
